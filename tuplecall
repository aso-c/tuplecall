//
// Calling function with parameters,
// packaged in a tuple.
//
// tuplecall
// Header file
//
// author: Solomatov A.A. (aso)
// ver.  : v.1.0.4
// date  : 12.07.22.
//
// Copyright (c) 2022 Andrey "aso" Solomatov
// This project is licensed under the terms of the MIT license.


//
// Usage:
//
//#include <functional>
//      . . .
//
//#include <tuplecall>
//      . . .
//
//    Tuple<Type_List>::simple_call(exec, items);
//
// or
//
//    Tuple<Type_List>::simple::call(exec, items);
//
//

#ifndef __TUPLECALL_ASO__
#define __TUPLECALL_ASO__


namespace aso
{

    template <typename ...ParamTypes>
    class Tuple
    {
    public:

//	template <typename TypeRet>
//	static TypeRet tuple_caller(std::function<TypeRet(ParamTypes...)>&& fn, const std::tuple<ParamTypes...>& argstuple) {
//	    return simple_caller<sizeof...(ParamTypes)>::invoke(fn, argstuple); };
//
//	template <typename TypeRet>
//	static TypeRet tuple_caller(std::function<TypeRet(ParamTypes...)>& fn, const std::tuple<ParamTypes...>& argstuple) {
//	return simple_caller<sizeof...(ParamTypes)>::invoke(fn, argstuple); };
//
//	template <typename TypeRet, TypeRet(*fn)(ParamTypes...)>
//	static TypeRet tuple_caller2(/*std::function<TypeRet(ParamTypes...)>&& fn,*/ const std::tuple<ParamTypes...>& argstuple) {
//	    return simple_caller<sizeof...(ParamTypes)>::invoke(fn, argstuple); };
//
	template <typename FnType>
	static auto simple_call( FnType fn, const std::tuple<ParamTypes...>& argstuple) -> typename std::result_of<FnType(ParamTypes...)>::type
	{
	    return simple::call(fn, argstuple);
	};

    public:
    	class simple
    	{
    	public:

    	    template <typename FnType>
    	    static auto call(FnType fn, const std::tuple<ParamTypes...>& argstuple) -> typename std::result_of<FnType(ParamTypes...)>::type;

    	}; /* simple */


    private:

	template <std::size_t limit, std::size_t... params>
	class caller
	{
	public:

	    template <typename FnType>
	    static auto invoke(FnType fn, const std::tuple<ParamTypes...>& argstuple) -> typename std::result_of<FnType(ParamTypes...)>::type
	    {
		return caller<limit-1, limit-1, params...>::invoke(fn, argstuple); };

	}; /* caller */

	template <std::size_t... params>
	class caller<0, params...>
	{
	public:

	    template <typename FnType>
	    static auto invoke(FnType& fn, const std::tuple<ParamTypes...>& argstuple) -> typename std::result_of<FnType(ParamTypes...)>::type
	    {
		return fn(std::get<params>(argstuple)...); };

	}; /* caller<0, ParamTypes...> */

    }; /* Tuple */


template <typename ...ParamTypes>
template <typename FnType>
inline auto Tuple<ParamTypes...>::simple::call(FnType fn, const std::tuple<ParamTypes...>& argstuple) -> typename std::result_of<FnType(ParamTypes...)>::type {
	return caller<sizeof...(ParamTypes)>::invoke(fn, argstuple); };



    template <typename ReType, typename FnT, typename ...ParamTypes>
//    inline ReType simple_tuplecaller(std::function<ReType(ParamTypes...)>&& fn, const std::tuple<ParamTypes...>& tupleargs)
    inline ReType simple_tuplecaller(std::function<FnT>&& fn, const std::tuple<ParamTypes...>& tupleargs)
    {
	return Tuple<ParamTypes...>::tuple_caller(fn, tupleargs);
    }; /* simple_tuplecaller */

    template <typename ReType, typename FnT, typename ...ParamTypes>
//    inline ReType simple_tuplecaller(std::function<ReType(ParamTypes...)>& fn, const std::tuple<ParamTypes...>& tupleargs)
    inline ReType simple_tuplecaller(std::function<FnT>& fn, const std::tuple<ParamTypes...>& tupleargs)
    {
	return Tuple<ParamTypes...>::tuple_caller(fn, tupleargs);
    }; /* simple_tuplecaller */


//    template <typename ...ParamTypes>
//    template <typename ReType, /*std::function<ReType(ParamTypes...)>&& fn*/ ReType(*fn)(ParamTypes...)>
//    inline ReType simple_tuple_caller(const std::tuple<ParamTypes...>& tupleargs) {
//	return simple<ParamTypes...>::tuple_caller(fn, tupleargs);
//    };

}; // aso

#endif // __TUPLECALLER_ASO__

//--[ End of file tuplecall ]----------------------------------------------------------------------
